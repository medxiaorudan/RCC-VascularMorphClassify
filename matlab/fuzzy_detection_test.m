clear all;
close all;
clc;

% format long;

[pathstr, name, ext] = fileparts(pwd()); 
addpath(genpath(pathstr)) %add all subdirectories of "motimo" folder

% Loading the test image

% path to image
% main_histo_data = 'C:\Users\Rita Simoes\Documents\Data\histo_kidney\Lame virtuelle\10.08.2014';
main_histo_data = '../10.08.2014';
case_folder = [main_histo_data,'/hp14.1993'];
% case_folder = [main_histo_data,'/hp14.5347'];
% case_folder = [main_histo_data,'/hp14.64'];
% case_folder = [main_histo_data,'/hp14.1749'];
level = 0;

% parameters according to image resolution
switch level % assumes that the gaussian pyramid has been generated by the python script "image_pyramid.py"
    case 0
        path_image = [case_folder,'/level0_crop.png'];
%         path_image = [case_folder,'/level0.png'];
        neigh_size = 15; % size of the neighborhood for the filters
        small_obj = 20; % size of the small objects that should be removed from binary segmentations( "noise")
        sigmas_hess = 20:40; % sigmas used by the gaussian derivatives (around the size of the nuclei)
        % to compute the pixelswise hessian matrices
        sigmas_frangi = [10 40]; % same as above; the sigmas should be around the width of the vessels
    case 0.5
        path_image = [case_folder,'/level0.5_crop_gaupyr.png'];
        neigh_size = 3;
        small_obj = 10;
        sigmas_hess = 5:10;
        sigmas_frangi = [4 20];
    case 1
        path_image = [case_folder,'/level1.0_crop_gaupyr.png']; %or level1_crop_leica
        neigh_size = 3;
        small_obj = 5;
        sigmas_hess = 2:8;
        sigmas_frangi = [2 10];
end

img = im2double(imread(path_image)); % load image
img = flipdim(flipdim(img,1),2); % flip dims to match the Leica viewer
% img = img(1:floor(end/4), 1:floor(end/4), :);

img1 = rescale01(img(:,:,1));
img2 = rescale01(img(:,:,2));
img3 = rescale01(img(:,:,3));
img = cat(3,img1,img2,img3);

% make some channel combinations
img_mean = mean(img,3); img_mean = rescale01(img_mean); 
img_min = min(img1, min(img2, img3)); img_min = rescale01(img_min); 
img_max = max(img1, max(img2, img3)); img_max = rescale01(img_max); 

% figure, imshow(img);
% 
% % Normalized-blue image
% im_bn = normalized_blue_image( img );
% figure, imshow(im_bn), title('Normalized-blue image');
% 
% im_brown = brown_image( img );
% figure, imshow(im_brown), title('Brown image');
% 
% [ im_c1, im_c2, im_c3 ] = invariant_colors( img );
% figure, imshow(im_c1), title('C1');
% figure, imshow(im_c2), title('C2');
% figure, imshow(im_c3), title('C3');

[ im_h ] = image_h( img );
figure, imshow(im_h), title('Hematoxylin');



I = double(im_h);
% 
% classType = class(im_h);
% scalingFactor = double(intmax(classType));
% I = I/scalingFactor;

Gx = [-1 1];
Gy = Gx';
Ix = conv2(I,Gx,'same');
Iy = conv2(I,Gy,'same');

figure; image(Ix,'CDataMapping','scaled'); colormap('gray'); title('Ix');
figure; image(Iy,'CDataMapping','scaled'); colormap('gray'); title('Iy');

edgeFIS = newfis('edgeDetection');

edgeFIS = addvar(edgeFIS,'input','Ix',[-1 1]);
edgeFIS = addvar(edgeFIS,'input','Iy',[-1 1]);

sx = 0.1; sy = 0.1;
edgeFIS = addmf(edgeFIS,'input',1,'zero','gaussmf',[sx 0]);
edgeFIS = addmf(edgeFIS,'input',2,'zero','gaussmf',[sy 0]);


edgeFIS = addvar(edgeFIS,'output','Iout',[0 1]);

wa = 0.1; wb = 1; wc = 1;
ba = 0; bb = 0; bc = .7;
edgeFIS = addmf(edgeFIS,'output',1,'white','trimf',[wa wb wc]);
edgeFIS = addmf(edgeFIS,'output',1,'black','trimf',[ba bb bc]);

figure
subplot(2,2,1); plotmf(edgeFIS,'input',1); title('Ix');
subplot(2,2,2); plotmf(edgeFIS,'input',2); title('Iy');
subplot(2,2,[3 4]); plotmf(edgeFIS,'output',1); title('Iout')

r1 = 'If Ix is zero and Iy is zero then Iout is white';
r2 = 'If Ix is not zero or Iy is not zero then Iout is black';
r = char(r1,r2);
edgeFIS = parsrule(edgeFIS,r);
showrule(edgeFIS)

Ieval = zeros(size(I));% Preallocate the output matrix
for ii = 1:size(I,1)
    Ieval(ii,:) = evalfis([(Ix(ii,:));(Iy(ii,:));]',edgeFIS);
end

figure; image(I,'CDataMapping','scaled'); colormap('gray');
title('Original Grayscale Image')

figure; image(Ieval,'CDataMapping','scaled'); colormap('gray');
title('Edge Detection Using Fuzzy Logic')